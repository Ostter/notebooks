import * as R from "ramda";

export const getNotebookById = (state, id) => R.prop(id, state.notebooks);

//список ноутбуков для показа на одной странице
//upd. добавил в код поиска фильтр по SEARCH и по Category
export const getNotebooks = (state, ownProps) => {
  const activeCategoryId = getActiveCategoryId(ownProps);
  console.log("activeCategoryId/getNotebooks/ownProps", activeCategoryId);
  const applySearch = item =>
    R.contains(state.notebooksPage.search, R.prop("name", item));
  //R.prop('categoryId', item) === item.categoryId
  //R.equals: item.categoryId === activeCategoryId?
  const applyCategory = item =>
    R.equals(activeCategoryId, R.prop("categoryId", item));
  console.log("const applyCategory", applyCategory);

  const notebooks = R.compose(
    R.filter(applySearch),
    //always - возвращает функцию "() = > activeCategoryId", чтобы ее не писать
    //when - если есть activeCategoryId, то применяем filter, т.е необходимо ли их фильтровать по category?
    R.when(R.always(activeCategoryId), R.filter(applyCategory)),
    R.map(id => getNotebookById(state, id))
  )(state.notebooksPage.ids);

  return notebooks;
};

//количество товаров уже отрендреренных на странице (длина массива, по сути)
export const getRenderedNotebooksLength = state =>
  R.length(state.notebooksPage.ids);

//value - получает все value в виде массива
export const getCategories = state => R.values(state.categories);

//путь - ownProps.match.params.id;
// R.path проверяет путь из параметров, если параметра нет, то undefined
export const getActiveCategoryId = ownProps => {
  console.log("SELECTOR ownProps", ownProps.match.params.id);
  R.path(["match", "params", "id"], ownProps);
  return ownProps.match.params.id;
};
