import * as R from 'ramda'

export const getNotebookById = (state, id) => R.prop(id, state.notebooks);

//список ноутбуков для показа на одной странице
// export const getNotebooks = state => {
//   const notebooks = R.map(id => getNotebookById(state, id), state.notebooksPage.ids);
//   return notebooks
// }

//upd. добавили в код поиска фильтр по SEARCH
// export const getNotebooks = state => {
//     const applySearch = item => R.contains( //проверяет, есть ли строка в подстроке
//         state.notebooksPage.search, //к моменту вызова getNotebooks в state.notebooksPage.search уже сохранен текст поиска
//         R.prop('name', item) //ищем текст поиска в каждом item.text
//     )
//     const notebooks = R.compose(
//         R.filter(applySearch), //2. Примени поиск ко всем объектам
//         R.map(id => getNotebookById(state, id)) //1. нашли массив объектов ноутбуков по их ID
//     )(state.notebooksPage.ids)
//
//     return notebooks
// }
//upd. добавил в код поиска фильтр по SEARCH и по Category
export const getNotebooks = (state, ownProps) => {
    const activeCategoryId = getActiveCategoryId(ownProps)
	console.log('activeCategoryId/getNotebooks/ownProps', activeCategoryId)
    const applySearch = item => R.contains(
        state.notebooksPage.search,
        R.prop('name', item)
    )
    //R.prop('categoryId', item) === item.categoryId
    //R.equals: item.categoryId === activeCategoryId?
    const applyCategory = item => R.equals(
        activeCategoryId,
        R.prop('categoryId', item)
    )
    console.log('const applyCategory', applyCategory)

    const notebooks = R.compose(
        R.filter(applySearch),
        //always - возвращает функцию "() = > activeCategoryId", чтобы не писать стрелочную
        //when - если есть activeCategoryId, то применяем filter, т.е необходимо ли их фильтровать по category?
        R.when(R.always(activeCategoryId), R.filter(applyCategory)),
        R.map(id => getNotebookById(state, id))
    )(state.notebooksPage.ids)

    return notebooks
}

//количество товаров уже отрендреренных на странице (длина массива, по сути)
export const getRenderedNotebooksLength = state => R.length(state.notebooksPage.ids)

//value - получает все value в виде массива
export const getCategories = state => R.values(state.categories)

//путь - ownProps.params.id; ownProps.match.params.id;
// R.path проверяет путь из параметров, если параметра нет, то undefined
// Без path код упадет
export const getActiveCategoryId = ownProps => {
    console.log('SELECTOR ownProps', ownProps.match.params.id);
    R.path(['match', 'params', 'id'], ownProps)
    return ownProps.match.params.id 
}